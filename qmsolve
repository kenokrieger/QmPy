#!/usr/bin/env python3
"""
This is an executable script that uses the modules _fileio,
_interpolation, graphics, and solvers to solve the Schrodingers
equation and graphicate the results
"""

import argparse
import sys
import os
import numpy as np
from qmpy._fileio import _read_config, _write_data
from qmpy.solvers import schroedinger, calculate_expval, calculate_uncertainty
from qmpy.graphics import qm_plottings


class qmSolve():
    """
    Solves the 1D Schrodinger's time-independent equation
    for any type of potential and graphicates its solution. The
    output graphs are shown on screen after executing the program and
    the data generated by solving the Schrodinger's equation is written
    in a series of output files (potentials.dat, energies.dat, wavefuncs.dat,
    and expvalues.dat). It needs an input file named schrodinger.inp with
    the data needed to solve the equation. The schrodinger.inp file needs to
    have following format:

        mass = float
        xrange = float, float, int
        evrange = int, int
        interpolation = str (can be 'linear', 'polynomial', or 'cspline'))
        /pivots
        (float) (float)
        float float
        float float
        ...
        pivots/

    Example:
        # This is an example input file
        # lines beginning with a # are ignored in the readout.

        # Mass of the system
        mass = 4.0
        # xMin xMax nPoint
        xrange = -20.0, 20.0, 1999
        # first and last eigenvalue to include in the output
        evrange = 1, 10
        # interpolation type
        interpolation = cspline
        # declaration of pivots for interpolation
        /pivots
        -20.0 35.0
        -10.0 0.0
        0.0 2.0
        10.0 0.0
        20.0 35.0
        pivots/

    """

    def __init__(self):
        description = "".join((
            "Solves the Schrodinger equation and graphicates its results.\n",
            "For more information see the README at https://github.com/kenokrieger/QmPy."
            ))
        parser = argparse.ArgumentParser(description=description)
        msg = \
"""The script support computing and visualising the results of solving the
1 dimensional schrodinger equation for a given set of potential values. Use
"qmsolve compute" to compute the wavefunctions and energies and "qmsolve visualise"
to visualise them.
"""
        parser.add_argument("command", help=msg)
        # parse_args defaults to [1:] for args, but you need to
        # exclude the rest of the args too, or validation will fail
        args = parser.parse_args(sys.argv[1:2])
        if not hasattr(self, args.command):
            print("Unrecognized command")
            parser.print_help()
            exit(1)
        else:
            argsopts = _validate_input(_parsecmd())
            # use dispatch pattern to invoke method with same name
            getattr(self, args.command)(argsopts)

    def compute(self, argsopts):
        """
        Computes energies, wavefunctions and expected values for a
        quantum-mechanical problem and stores its solution in various .dat
        files.

        Args:
            argsopts (dict): Dictionary containing the input from the command
                line.

        Returns:
            None.

        """
        schrodingers_path = os.path.join(argsopts["ipath"], "schrodinger.inp")
        try:
            specs = _read_config(schrodingers_path)
            print("Running with configuration")
            for key, value in specs.items():
                print("\t{0}: {1}".format(key, value))
        except FileNotFoundError:
            msg = "Input file or path was not found."
            print(msg)
            exit()
        except OSError:
            msg = "Input file could not be read."
            print(msg)
            exit()
        except ValueError as exc:
            print(exc)
            exit()
        else:
            print("Computing wavefunctions and energies...")
            vals = dict()
            vals["mass"] = specs["mass"]
            vals["xcords"] = specs["pivots"][:, 0]
            vals['potential'] = specs["pivots"][:, 1]
            vals['xopt'] = specs["xrange"]

            # translate range into python range starting with 0
            ev_range = tuple(evidx - 1 for evidx in specs["evrange"])
            sol = schroedinger(vals, select_range=ev_range, interpol=True,
                               interpoltype=specs["interpolation"])
            energies, wfuncs, pot = sol[0], sol[1], sol[2]
            xcords = pot[:, 0].T
            savefuncs = np.insert(wfuncs.T, 0, xcords, axis=1)
            expvals = calculate_expval(xcords, wfuncs)
            uncertainties = calculate_uncertainty(xcords, wfuncs)

            expvaldata = np.vstack((expvals, uncertainties)).T

            print("Writing output to {0}".format(argsopts["opath"]))
            _write_data(argsopts["opath"], pot, energies, savefuncs,
                        expvaldata)
            print("Done.")


    def visualise(self, argsopts):
        """
        Visualises the solution of the 1 dimensional schrodinger equation.
        """
        sname = os.path.join(argsopts["opath"], argsopts["namefile"])
        try:
            print("Starting visualisation...")
            qm_plottings(argsopts["ipath"], argsopts["autoscale"],
                         argsopts["scale"], argsopts["xrange"],
                         argsopts["yrange"], sname, argsopts["show"])
        except FileNotFoundError:
            msg = 'Input file(s) could not be found.'
            print(msg)
        except OSError:
            msg = 'Input file(s) could not be read.'
            print(msg)
        else:
            print("Done.")
            print("Generated output file at '{}'".format(sname))


def _parsecmd():
    """
    Parses the input from the command line to the program.

    Returns:
        argsopts: Dictionary that contains various options for the command
            line parsing.

    """
    description = 'Solves the Schrodinger equation and graphicates its results'
    parser = argparse.ArgumentParser(description=description)
    msg = "Input directory"
    parser.add_argument('-i', '--idirectory', default='.', help=msg)
    msg = "Output directory"
    parser.add_argument('-o', '--odirectory', default='.', help=msg)
    msg = "Scale factor for the wave functions"
    parser.add_argument('-s', '--sfactor', default=None, help=msg, type=float)
    msg = "Auto-scalation function for the plots. True or False."
    parser.add_argument('-a', '--autoscale', default=True, help=msg)
    msg = "Name of the file the plot is saved to"
    parser.add_argument('-n', '--namefile', default='qmpy_plot.pdf', help=msg)
    msg = """
    Plotting range separated by \':\'. For negative values use a \'n\' instead
    of a \'-\' e.g: n5.0:5.0 will return a plot ranging from -5 to 5
    """
    parser.add_argument('-x', '--xrange', default=None, help=msg)
    parser.add_argument('-y', '--yrange', default=None, help=msg)
    msg = "Show plot window"
    parser.add_argument("-v", "--show", default=False, action="store_true", help=msg)
    args = parser.parse_args(sys.argv[2:])
    return args


def _validate_input(args):
    """
    Converts all string input from the command line to its respective types
    needed for further processing. In case of invalid input the default value
    will be used and the user will be notified.

    Args:
        args (argparse-object): Parser containing all the information supplied
            through the command line.

    Returns:
        dict: A dictionary containing the arguments from the command line
            where invalid inputs where set to their default values.

    """
    argsopts = dict()
    argsopts["ipath"] = os.path.expanduser(args.idirectory)
    argsopts["opath"] = os.path.expanduser(args.odirectory)
    argsopts["namefile"] = args.namefile
    argsopts['scale'] = args.sfactor
    argsopts["show"] = args.show

    if args.autoscale == 'False':
        argsopts["autoscale"] = False
    elif args.autoscale in ['True', True]:
        argsopts['autoscale'] = True
    else:
        print('Invalid option for \'--autoscale\': {}'.format(args.autoscale))
        exit()

    for arg, key in zip((args.xrange, args.yrange), ('xrange', 'yrange')):
        if arg is not None:
            try:
                axrange = tuple([float(s.replace('n', '-')) for s in
                                 arg.split(':')])
            except ValueError:
                print('Could not convert input to float: {}'.format(
                        tuple(arg.split(':'))))
                exit()
            else:
                argsopts[key] = axrange
        else:
            argsopts[key] = arg

    return argsopts


def main():
    """
    Main function of the script.
    """
    qmSolve()


if __name__ == "__main__":
    main()
