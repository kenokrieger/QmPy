#!/usr/bin/env python3
"""
This is an executable script that uses the modules _fileio,
_interpolation, graphics, and solvers to solve the Schrodingers
equation and graphicate the results
"""

import argparse
import sys
import os
import numpy as np
from qmpy._fileio import _read_config, _write_data
from qmpy.solvers import schroedinger, calculate_expval, calculate_uncertainty
from qmpy.graphics import qm_plottings


class qmSolve():
    """
    Solves the 1D Schrodinger's time-independent equation
    for any type of potential and graphicates its solution. The
    output graphs are shown on screen after executing the program and
    the data generated by solving the Schrodinger's equation is written
    in a series of output files (potentials.dat, energies.dat, wavefuncs.dat,
    and expvalues.dat). It needs an input file named schrodinger.inp with
    the data needed to solve the equation in json format.

    Example:
        {
          "computation": {
            "mass": 4.0,
            "xrange": {
              "xmin": -20.0,
              "xmax":  20.0,
              "npoint": 1999
            },
            "evrange": [1, 10],
            "interpolation.type": "cspline",
            "potential": {
              "x.values": [-20.0, -10.0, 0.0, 10.0, 20.0],
              "y.values": [35.0, 0.0, 2.0, 0.0, 35.0]
            }
          },
          "visualisation": null
}

    """

    def __init__(self):
        description = "".join((
            "Solves the Schrodinger equation and graphicates its results.\n",
            "For more information see the README at https://github.com/kenokrieger/QmPy."
            ))
        parser = argparse.ArgumentParser(description=description)
        msg = \
"""The script support computing and visualising the results of solving the
1 dimensional schrodinger equation for a given set of potential values. Use
"qmsolve compute" to compute the wavefunctions and energies and "qmsolve visualise"
to visualise them.
"""
        parser.add_argument("command", help=msg)
        # parse_args defaults to [1:] for args, but you need to
        # exclude the rest of the args too, or validation will fail
        args = parser.parse_args(sys.argv[1:2])
        if not hasattr(self, args.command):
            print("Unrecognized command")
            parser.print_help()
            return

        argsopts = _parsecmd()
        # use dispatch pattern to invoke method with same name
        getattr(self, args.command)(argsopts)

    def compute(self, argsopts):
        """
        Computes energies, wavefunctions and expected values for a
        quantum-mechanical problem and stores its solution in various .dat
        files.

        Args:
            argsopts (dict): Dictionary containing the input from the command
                line.

        Returns:
            None.

        """
        config_filename = os.path.expanduser(argsopts.config_file)
        try:
            specs = _read_config(config_filename)["computation"]
        except OSError as e:
            msg = "Error when reading file '{}': {}".format(config_filename, e)
            print(msg)
            return
        except ValueError as exc:
            print(exc)
            return

        print("Computing wavefunctions and energies...")
        vals = dict()
        vals["mass"] = specs["mass"]
        vals["xcords"] = np.array(specs["potential"]["x.values"])
        vals['potential'] = np.array(specs["potential"]["y.values"])
        vals['xopt'] = (
            specs["xrange"]["xmin"], specs["xrange"]["xmax"],
            specs["xrange"]["npoint"]
        )

        # translate range into python range starting with 0
        ev_range = tuple(evidx - 1 for evidx in specs["evrange"])
        sol = schroedinger(vals, select_range=ev_range, interpol=True,
                           interpoltype=specs["interpolation.type"])
        energies, wfuncs, pot = sol[0], sol[1], sol[2]
        xcords = pot[:, 0].T
        savefuncs = np.insert(wfuncs.T, 0, xcords, axis=1)
        expvals = calculate_expval(xcords, wfuncs)
        uncertainties = calculate_uncertainty(xcords, wfuncs)

        expvaldata = np.vstack((expvals, uncertainties)).T

        print("Writing output to {}".format(argsopts.odirectory))
        _write_data(argsopts.odirectory, pot, energies, savefuncs,
                    expvaldata)
        print("Done.")


    def visualise(self, argsopts):
        """
        Visualises the solution of the 1 dimensional schrodinger equation.
        """
        sname = os.path.expanduser(argsopts.namefile)
        try:
            print("Starting visualisation...")
            qm_plottings(os.path.expanduser(argsopts.idirectory),
                         argsopts.autoscale, argsopts.sfactor, None,
                         None, sname, argsopts.show)
        except OSError as e:
            msg = "Error when reading data file(s): {}".format(e)
            print(msg)
            return

        print("Done.")
        print("Generated output file '{}'".format(sname))


def _parsecmd():
    """
    Parses the input from the command line to the program.

    Returns:
        argsopts: Dictionary that contains various options for the command
            line parsing.

    """
    description = 'Solves the Schrodinger equation and visualises its results'
    parser = argparse.ArgumentParser(description=description)
    msg = "Configuration file name"
    parser.add_argument("-c", "--config-file", default="schrodinger.json",
                        help=msg)
    msg = "Input directory"
    parser.add_argument('-i', '--idirectory', default='.', help=msg)
    msg = "Output directory"
    parser.add_argument('-o', '--odirectory', default='.', help=msg)
    msg = "Scale factor for the wave functions"
    parser.add_argument('-s', '--sfactor', default=None, help=msg, type=float)
    msg = "Auto-scalation option for the plots"
    parser.add_argument('-a', '--autoscale', default=True, action="store_false",
                        help=msg)
    msg = "Name of the file the plot is saved to"
    parser.add_argument('-n', '--namefile', default='qmpy_plot.pdf', help=msg)
    msg = "Show plot window"
    parser.add_argument("-v", "--show", default=False, action="store_true",
                        help=msg)
    args = parser.parse_args(sys.argv[2:])
    return args


def main():
    """
    Main function of the script.
    """
    qmSolve()


if __name__ == "__main__":
    main()
