#!/usr/bin/env python3
"""
This is an executable script that uses the modules _fileio,
_interpolation, graphics, and solvers to solve the Schrodingers
equation and graphicate the results
"""

import argparse
import os
import numpy as np
from qmpy._fileio import _read_schrodinger, _write_data
from qmpy.solvers import schroedinger, calculate_expval, calculate_uncertainty
from qmpy.graphics import qm_plottings


def schrodingers_solver():
    """
    Solves the 1D Schrodinger's time-independent equation
    for any type of potential and graphicates its solution. The
    output graphs are shown on screen after executing the program and
    the data generated by solving the Schrodinger's equation is written
    in a series of output files (potentials.dat, energies.dat, wavefuncs.dat,
    and expvalues.dat). It needs an input file named schrodinger.inp with
    the data needed to solve the equation. The schrodinger.inp file needs to
    have following format:

        (float) # mass
        (float) (float) (int) # xMin xMax nPoint
        (int) (int) # first and last eigenvalue to print
        (str(can be linear, polynomial, or cspline)) # interpolation type
        (int) # nr. of interpolation points and xy declarations
        (float) (float)
        ...

    Example:
        2.0 # mass
        -2.0 2.0 1999 # xMin xMax nPoint
        1 5 # first and last eigenvalue to print
        linear # interpolation type
        2 # nr. of interpolation points and xy declarations
        -2.0 0.0
        2.0 0.0

    """
    argsopts = _validate_input(_parsecmd())

    if argsopts['compute']:
        compute(argsopts)
        # depending on which option for computing was selected, qm_plottings
        # will either look for the .dat files in the input or output directory
        dirname = argsopts['opath']
        print('Computation was successful.')
    else:
        dirname = argsopts['ipath']

    if argsopts['visualize']:
        sname = os.path.join(argsopts['opath'], argsopts['namefile'])
        try:
            qm_plottings(dirname, argsopts["autoscale"],
                         argsopts["scale"], argsopts["xrange"],
                         argsopts["yrange"], sname)
        except FileNotFoundError:
            msg = 'Input file(s) could not be found.'
            print(msg)
        except OSError:
            msg = 'Input file(s) could not be read.'
            print(msg)
        else:
            print('Visualization was successful.')


def compute(argsopts):
    """
    Computes energies, wavefunctions and expected values for a
    quantum-mechanical problem and stores its solution in various .dat files.

    Args:
        argsopts (dict): Dictionary containing the input from the command line.

    Returns:
        None.

    """
    schrodingers_path = os.path.join(argsopts["ipath"], "schrodinger.inp")
    try:
        specs = _read_schrodinger(schrodingers_path)
    except FileNotFoundError:
        msg = "Input file or path was not found."
        print(msg)
    except OSError:
        msg = "Input file could not be read."
        print(msg)
    else:
        vals = dict()
        vals['mass'] = specs['mass']
        vals['xcords'] = specs['interpolxydecs'][:, 0]
        vals['potential'] = specs['interpolxydecs'][:, 1]
        vals['xopt'] = specs['xopt']

        # translate range into python range starting with 0
        ev_range = (specs['first_ev'] - 1, specs['last_ev'] - 1)
        sol = schroedinger(vals, select_range=ev_range, interpol=True,
                           interpoltype=specs['interpoltype'])
        energies, wfuncs, pot = sol[0], sol[1], sol[2]
        xcords = pot[:, 0].T
        savefuncs = np.insert(wfuncs.T, 0, xcords, axis=1)
        expvals = calculate_expval(xcords, wfuncs)
        uncertainties = calculate_uncertainty(xcords, wfuncs)

        expvaldata = np.vstack((expvals, uncertainties)).T

        _write_data(argsopts["opath"], pot, energies, savefuncs,
                    expvaldata)


def _parsecmd():
    """
    Parses the input from the command line to the program.

    Returns:
        argsopts: Dictionary that contains various options for the command
        line parsing

    """
    description = 'Solves the Schrodinger equation and graphicates its results'
    parser = argparse.ArgumentParser(description=description)
    msg = 'Compute wavefunctions, energies and expected values'
    parser.add_argument('-C', '--compute', action='store_true', help=msg)
    msg = 'Visualize the result and save it'
    parser.add_argument('-V', '--visualize', action='store_true', help=msg)
    msg = "Input directory"
    parser.add_argument('-i', '--idirectory', default='.', help=msg)
    msg = "Output directory"
    parser.add_argument('-o', '--odirectory', default='.', help=msg)
    msg = "Scale factor for the wave functions"
    parser.add_argument('-s', '--sfactor', default=None, help=msg, type=float)
    msg = "Auto-scalation function for the plots. True or False."
    parser.add_argument('-a', '--autoscale', default=True, help=msg)
    msg = "Name of the file the plot is saved to"
    parser.add_argument('-n', '--namefile', default='qmpy_plot.pdf', help=msg)
    msg = """
    Plotting range separated by \':\'. For negative values use a \'n\' instead
    of a \'-\' e.g: n5.0:5.0 will return a plot ranging from -5 to 5
    """
    parser.add_argument('-x', '--xrange', default=None, help=msg)
    parser.add_argument('-y', '--yrange', default=None, help=msg)
    args = parser.parse_args()
    return args


def _validate_input(args):
    """
    Converts all string input from the command line to its respective types
    needed for further processing. In case of invalid input the default value
    will be used and the user will be notified.

    Args:
        args (argparse-object): Parser containing all the information supplied
            through the command line.

    Returns:
        dict: A dictionary containing the arguments from the command line
            where invalid inputs where set to their default values.

    """
    if not (args.compute or args.visualize):
        msg = """No option for computation or visualization was selected.
Use -C for computation and/or -V for visualization."""
        print(msg)
        exit()

    argsopts = dict()
    argsopts['compute'] = args.compute
    argsopts['visualize'] = args.visualize
    argsopts["ipath"] = args.idirectory
    argsopts["opath"] = args.odirectory
    argsopts["namefile"] = args.namefile
    argsopts['scale'] = args.sfactor

    if args.autoscale == 'False':
        argsopts["autoscale"] = False
    elif args.autoscale in ['True', True]:
        argsopts['autoscale'] = True
    else:
        print('Invalid option for \'--autoscale\': {}'.format(args.autoscale))
        exit()

    for arg, key in zip((args.xrange, args.yrange), ('xrange', 'yrange')):
        if arg is not None:
            try:
                axrange = tuple([float(s.replace('n', '-')) for s in
                                 arg.split(':')])
            except ValueError:
                print('Could not convert input to float: {}'.format(
                        tuple(arg.split(':'))))
                exit()
            else:
                argsopts[key] = axrange
        else:
            argsopts[key] = arg

    return argsopts


if __name__ == "__main__":
    schrodingers_solver()
