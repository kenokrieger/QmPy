qmsolve
*******

qmsolve is a python script which uses the modules from the QmPy package to
solve and visualize a quantum mechanical problem by numerically solving the
1-dimensional schrodinger equation. It can be run from the command line with
various optional arguments.

Here's the source code:

.. code-block:: python

    """
    This is an executable script that uses the modules _fileio,
    _interpolation, graphics, and solvers to solve the Schrodingers
    equation and graphicate the results
    """

    import argparse
    import os
    import numpy as np
    from qmpy._fileio import _read_schrodinger, _write_data
    from qmpy._interpolation import _interpolate
    from qmpy.solvers import schroedinger, calculate_expval, calculate_uncertainty
    from qmpy.graphics import qm_plottings


    def schrodingers_solver():
        """
        Solves the 1D Schrodinger's time-independent equation
        for any type of potential and graphicates its solution. The
        output graphs are shown on screen after executing the program and
        the data generated by solving the Schrodinger's equation is written
        in a series of output files (potentials.dat, energies.dat, wavefuncs.dat,
        and expvalues.dat). It needs an input file named schrodinger.inp with
        the data needed to solve the equation. The schrodinger.inp file needs to
        have following format:

            (float) # mass
            (float) (float) (int) # xMin xMax nPoint
            (int) (int) # first and last eigenvalue to print
            (str(can be linear, polynomial, or cspline)) # interpolation type
            (int) # nr. of interpolation points and xy declarations
            (float) (float)
            ...

        Example:
            2.0 # mass
            -2.0 2.0 1999 # xMin xMax nPoint
            1 5 # first and last eigenvalue to print
            linear # interpolation type
            2 # nr. of interpolation points and xy declarations
            -2.0 0.0
            2.0 0.0

        """
        argsopts = _validate_input(_parsecmd())
        schrodingers_path = os.path.join(argsopts["ipath"], "schrodinger.inp")
        try:
            specs = _read_schrodinger(schrodingers_path)
        except FileNotFoundError:
            msg = "Input file or path was not found."
            print(msg)
        except PermissionError:
            msg = "Input file could not be read, please check the file permissions"
            print(msg)
        else:
            xx = specs['interpolxydecs'][:, 0]
            yy = specs['interpolxydecs'][:, 1]
            xint, pots = _interpolate(xx, yy, specs['xopt'], specs['interpoltype'])
            pot = np.vstack((xint, pots)).T
            # translate range into python range starting with 0
            ev_range = (specs['first_ev'] - 1, specs['last_ev'] - 1)
            energies, wfuncs = schroedinger(specs['mass'], xint, pots,
                                            select_range=ev_range)
            savefuncs = np.insert(wfuncs.T, 0, xint, axis=1)
            expvals = calculate_expval(xint, wfuncs)
            uncertainties = calculate_uncertainty(xint, wfuncs)

            expvaldata = np.vstack((expvals, uncertainties)).T

            _write_data(argsopts["opath"], pot, energies, savefuncs, expvaldata)
            qm_plottings(argsopts["opath"], argsopts["autoscale"],
                         argsopts["scale"], argsopts["xrange"],
                         argsopts["yrange"], argsopts["namefile"])


    def _parsecmd():
        """
        Parses the input from the command line to the program.

        Returns:
            argsopts: Dictionary that contains various options for the command
            line parsing

        """
        description = 'Solves the Schrodinger equation and graphicates its results'
        parser = argparse.ArgumentParser(description=description)
        msg = "Input directory"
        parser.add_argument('-i', '--idirectory', default='.', help=msg)
        msg = "Output directory"
        parser.add_argument('-o', '--odirectory', default='.', help=msg)
        msg = "Scale factor for the wave functions"
        parser.add_argument('-s', '--sfactor', default=None, help=msg)
        msg = "Auto-scalation function for the plots. True or False."
        parser.add_argument('-a', '--autoscale', default=True, help=msg)
        msg = "Name of the file the plot is saved to"
        parser.add_argument('-n', '--namefile', default='qmpy_plot.pdf', help=msg)
        msg = """
        Plotting range separated by \':\'. For negative values use a \'n\' instead
        of a \'-\' e.g: n5.0:5.0 will return a plot ranging from -5 to 5
        """
        parser.add_argument('-x', '--xrange', default=None, help=msg)
        parser.add_argument('-y', '--yrange', default=None, help=msg)
        args = parser.parse_args()
        return args


    def _validate_input(args):
        """
        Converts all string input from the command line to its respective types
        needed for further processing. In case of invalid input the default value
        will be used and the user will be notified.

        Args:
            args (argparse-object): Parser containing all the information supplied
                through the command line.

        Returns:
            dict: A dictionary containing the arguments from the command line
                where invalid inputs where set to their default values.

        """
        argsopts = dict()
        argsopts["ipath"] = args.idirectory
        argsopts["opath"] = args.odirectory
        argsopts["namefile"] = args.namefile

        if args.sfactor is not None:
            try:
                argsopts["scale"] = float(args.sfactor)
            except ValueError:
                print('Could not convert input to float: {}'.format(args.sfactor))
                print('Using default...')
                argsopts['scale'] = None
        else:
            argsopts['scale'] = None

        if args.autoscale == 'False':
            argsopts["autoscale"] = False
        elif args.autoscale in ['True', True]:
            argsopts['autoscale'] = True
        else:
            print('Invalid option for \'--autoscale\': {}'.format(args.autoscale))
            print('Using default')
            argsopts['autoscale'] = True

        for arg, key in zip((args.xrange, args.yrange), ('xrange', 'yrange')):
            if arg is not None:
                try:
                    axrange = map(lambda s: s.replace('n', '-'), arg.split(':'))
                    # conversion of map object to tuple here is necessary so
                    # that the ValueError does not occur later in the code
                    rangeasfloat = tuple(map(float, axrange))
                except ValueError:
                    print('Could not convert input to float: {}'.format(
                        tuple(arg.split(':'))))
                    print('Using default...')
                    argsopts[key] = None
                else:
                    argsopts[key] = rangeasfloat
            else:
                argsopts[key] = arg

        return argsopts


    if __name__ == "__main__":
        schrodingers_solver()
